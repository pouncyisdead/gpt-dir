=== CONVERSION from '/home/project/src' ===

=== DETAILS ===
Generated: 8/12/2025, 10:57:49 AM
Options: minify=true, escape=true, tree=true
Files: 5 processed, 0 skipped
Size: 18.13 KB
Duration: 7ms
=== END DETAILS ===

=== TREE ===
üìÅ src/
‚îî‚îÄ‚îÄ üìÅ src/
    ‚îú‚îÄ‚îÄ üî∑ converter.ts/
    ‚îú‚îÄ‚îÄ üî∑ file-processor.ts/
    ‚îú‚îÄ‚îÄ üî∑ gpt-dir.ts/
    ‚îú‚îÄ‚îÄ üî∑ tree-generator.ts/
    ‚îî‚îÄ‚îÄ üî∑ types.ts/

=== END TREE ===

=== FILES ===

=== FILE: 'converter.ts' ===
import * as fs from \'fs/promises\';\nimport * as path from \'path\';\nimport chalk from \'chalk\';\nimport cliProgress from \'cli-progress\';\nimport { ConversionOptions, FileStats, ProcessedFile, ConversionResult } from \'./types\';\nimport { FileProcessor } from \'./file-processor\';\nimport { TreeGenerator } from \'./tree-generator\';\nexport class DirectoryConverter {\nprivate fileProcessor = new FileProcessor();\nprivate treeGenerator = new TreeGenerator();\nprivate progressBar?: cliProgress.SingleBar;\nasync convert(options: ConversionOptions): Promise<ConversionResult> {\nconst startTime = new Date();\nconsole.log(chalk.blue(\'üöÄ Starting directory conversion...\'));\n// Initialize stats\nconst stats: FileStats = {\ntotalFiles: 0,\nprocessedFiles: 0,\nskippedFiles: 0,\nfileTypes: {},\ntotalSize: 0\n};\nconst allFiles: ProcessedFile[] = [];\nlet tree = \'\';\n// Ensure output directory exists\nawait fs.mkdir(options.outputDir, { recursive: true });\n// Process each input directory\nfor (const inputDir of options.inputDirs) {\nconsole.log(chalk.yellow(`üìÇ Processing directory: ${inputDir}`));\n// Generate tree if requested\nif (options.tree) {\nconsole.log(chalk.cyan(\'üå≥ Generating directory tree...\'));\nconst dirTree = await this.treeGenerator.generateTree(inputDir);\ntree += `üìÅ ${path.basename(inputDir)}/\\n${dirTree}\\n`;\n}\n// Collect all files\nconst files = await this.collectFiles(inputDir);\nstats.totalFiles += files.length;\n// Initialize progress bar\nif (files.length > 0) {\nthis.progressBar = new cliProgress.SingleBar({\nformat: chalk.cyan(\'{bar}\') + \' | {percentage}% | {value}/{total} files\',\nbarCompleteChar: \'‚ñà\',\nbarIncompleteChar: \'‚ñë\',\nhideCursor: true\n});\nthis.progressBar.start(files.length, 0);\n}\n// Process files\nfor (const filePath of files) {\nawait this.processFile(filePath, inputDir, options, stats, allFiles);\nthis.progressBar?.increment();\n}\nthis.progressBar?.stop();\n}\nconst endTime = new Date();\n// Generate output file\nconst outputContent = this.generateOutput(options, stats, allFiles, tree, startTime, endTime);\nconst outputFileName = `conversion_${new Date().toISOString().replace(/[:.]/g, \'-\')}.txt`;\nconst outputPath = path.join(options.outputDir, outputFileName);\nawait fs.writeFile(outputPath, outputContent, \'utf8\');\nconsole.log(chalk.green(`‚úÖ Conversion completed!`));\nconsole.log(chalk.blue(`üìÑ Output file: ${outputPath}`));\nconsole.log(chalk.blue(`üìä Files processed: ${stats.processedFiles}/${stats.totalFiles}`));\nconsole.log(chalk.blue(`‚è±Ô∏è  Duration: ${endTime.getTime() - startTime.getTime()}ms`));\nreturn {\nstats,\nfiles: allFiles,\ntree,\nstartTime,\nendTime\n};\n}\nprivate async collectFiles(dirPath: string): Promise<string[]> {\nconst files: string[] = [];\nconst traverse = async (currentPath: string): Promise<void> => {\ntry {\nconst items = await fs.readdir(currentPath);\nfor (const item of items) {\nconst itemPath = path.join(currentPath, item);\nconst stats = await fs.stat(itemPath);\nif (stats.isDirectory()) {\nif (!this.fileProcessor.shouldExcludeDirectory(item)) {\nawait traverse(itemPath);\n}\n} else {\nif (!this.fileProcessor.shouldExcludeFile(item)) {\nfiles.push(itemPath);\n}\n}\n}\n} catch (error) {\nconsole.warn(chalk.yellow(`Warning: Could not read directory ${currentPath}`));\n}\n};\nawait traverse(dirPath);\nreturn files;\n}\nprivate async processFile(\nfilePath: string,\nrootDir: string,\noptions: ConversionOptions,\nstats: FileStats,\nallFiles: ProcessedFile[]\n): Promise<void> {\nconst result = await this.fileProcessor.processFile(filePath, {\nminify: options.minify,\nescape: options.escape\n});\nif (result) {\nconst relativePath = path.relative(rootDir, filePath);\nconst fileType = path.extname(filePath) || \'no-extension\';\nstats.processedFiles++;\nstats.totalSize += result.size;\nstats.fileTypes[fileType] = (stats.fileTypes[fileType] || 0) + 1;\nallFiles.push({\npath: filePath,\nrelativePath,\ncontent: result.content,\nsize: result.size,\ntype: fileType\n});\n} else {\nstats.skippedFiles++;\n}\n}\nprivate generateOutput(\noptions: ConversionOptions,\nstats: FileStats,\nfiles: ProcessedFile[],\ntree: string,\nstartTime: Date,\nendTime: Date\n): string {\nlet output = \'\';\n// Header\noptions.inputDirs.forEach(dir => {\noutput += `=== CONVERSION from \'${dir}\' ===\\n\\n`;\n});\n// Details section\noutput += \'=== DETAILS ===\\n\';\noutput += `Generated: ${new Date().toLocaleString()}\\n`;\noutput += `Options: minify=${options.minify}, escape=${options.escape}, tree=${options.tree}\\n`;\noutput += `Files: ${stats.processedFiles} processed, ${stats.skippedFiles} skipped\\n`;\noutput += `Size: ${(stats.totalSize / 1024).toFixed(2)} KB\\n`;\noutput += `Duration: ${endTime.getTime() - startTime.getTime()}ms\\n`;\noutput += \'=== END DETAILS ===\\n\\n\';\n// Tree section\nif (options.tree && tree) {\noutput += \'=== TREE ===\\n\';\noutput += tree;\noutput += \'=== END TREE ===\\n\\n\';\n}\n// Files section\noutput += \'=== FILES ===\\n\\n\';\nfor (const file of files) {\noutput += `=== FILE: \'${file.relativePath}\' ===\\n`;\noutput += file.content;\noutput += `\\n=== END FILE: \'${file.relativePath}\' ===\\n`;\noutput += `Size: ${file.size} bytes, Type: ${file.type}\\n\\n`;\n}\noutput += \'=== END FILES ===\\n\\n\';\noutput += \'=== END CONVERSION ===\\n\';\nreturn output;\n}\n}
=== END FILE: 'converter.ts' ===
Size: 6050 bytes, Type: .ts

=== FILE: 'file-processor.ts' ===
import * as fs from \'fs/promises\';\nimport * as path from \'path\';\nimport * as mime from \'mime-types\';\nexport class FileProcessor {\nprivate readonly maxFileSize = 1024 * 1024; // 1MB\nprivate readonly excludedExtensions = new Set([\n\'.exe\', \'.dll\', \'.so\', \'.dylib\', \'.zip\', \'.tar\', \'.gz\', \'.rar\',\n\'.jpg\', \'.jpeg\', \'.png\', \'.gif\', \'.bmp\', \'.ico\', \'.tiff\',\n\'.mp3\', \'.mp4\', \'.avi\', \'.mov\', \'.wmv\', \'.flv\',\n\'.pdf\', \'.doc\', \'.docx\', \'.xls\', \'.xlsx\', \'.ppt\', \'.pptx\'\n]);\nasync processFile(filePath: string, options: { minify: boolean; escape: boolean }): Promise<{ content: string; size: number } | null> {\ntry {\nconst stats = await fs.stat(filePath);\n// Skip large files\nif (stats.size > this.maxFileSize) {\nreturn null;\n}\n// Check if file is binary\nif (this.isBinaryFile(filePath)) {\nreturn null;\n}\nlet content = await fs.readFile(filePath, \'utf8\');\nconst originalSize = content.length;\n// Apply processing options\nif (options.minify) {\ncontent = this.minifyContent(content);\n}\nif (options.escape) {\ncontent = this.escapeContent(content);\n}\nreturn {\ncontent,\nsize: originalSize\n};\n} catch (error) {\nconsole.warn(`Warning: Could not process file ${filePath}: ${error}`);\nreturn null;\n}\n}\nprivate isBinaryFile(filePath: string): boolean {\nconst ext = path.extname(filePath).toLowerCase();\n// Check excluded extensions\nif (this.excludedExtensions.has(ext)) {\nreturn true;\n}\n// Check if it\'s a known text file first\nif (this.isTextFile(filePath)) {\nreturn false;\n}\n// Use MIME type detection\nconst mimeType = mime.lookup(filePath);\nif (mimeType && !mimeType.startsWith(\'text/\') && !this.isKnownTextType(mimeType)) {\nreturn true;\n}\nreturn false;\n}\nprivate isKnownTextType(mimeType: string): boolean {\nconst textTypes = [\n\'application/json\',\n\'application/xml\',\n\'application/javascript\',\n\'application/typescript\',\n\'application/x-yaml\',\n\'application/x-sh\'\n];\nreturn textTypes.some(type => mimeType.includes(type));\n}\nprivate isTextFile(filePath: string): boolean {\nconst ext = path.extname(filePath).toLowerCase();\n// Known text file extensions\nconst textExtensions = new Set([\n\'.js\', \'.jsx\', \'.ts\', \'.tsx\', \'.json\', \'.md\', \'.txt\', \'.html\', \'.htm\',\n\'.css\', \'.scss\', \'.sass\', \'.less\', \'.xml\', \'.yaml\', \'.yml\', \'.toml\',\n\'.ini\', \'.conf\', \'.config\', \'.env\', \'.gitignore\', \'.gitattributes\',\n\'.py\', \'.java\', \'.c\', \'.cpp\', \'.h\', \'.hpp\', \'.cs\', \'.php\', \'.rb\',\n\'.go\', \'.rs\', \'.swift\', \'.kt\', \'.scala\', \'.sh\', \'.bash\', \'.zsh\',\n\'.fish\', \'.ps1\', \'.bat\', \'.cmd\', \'.sql\', \'.r\', \'.m\', \'.pl\', \'.lua\',\n\'.vim\', \'.dockerfile\', \'.makefile\', \'.cmake\', \'.gradle\', \'.maven\'\n]);\nreturn textExtensions.has(ext);\n}\nprivate minifyContent(content: string): string {\nreturn content\n.split(\'\\n\')\n.map(line => line.trim())\n.filter(line => line.length > 0)\n.join(\'\\n\');\n}\nprivate escapeContent(content: string): string {\nreturn content\n.replace(/\\\\/g, \'\\\\\\\\\')\n.replace(/\"/g, \'\\\\\"\')\n.replace(/\'/g, \"\\\\\'\")\n.replace(/\\n/g, \'\\\\n\')\n.replace(/\\r/g, \'\\\\r\')\n.replace(/\\t/g, \'\\\\t\');\n}\nshouldExcludeDirectory(dirName: string): boolean {\nconst excludedDirs = new Set([\n\'node_modules\', \'.git\', \'.svn\', \'.hg\', \'dist\', \'build\',\n\'coverage\', \'.nyc_output\', \'.DS_Store\', \'Thumbs.db\'\n]);\nreturn excludedDirs.has(dirName) || dirName.startsWith(\'.\');\n}\nshouldExcludeFile(fileName: string): boolean {\nconst excludedFiles = new Set([\n\'.DS_Store\', \'Thumbs.db\', \'.gitignore\', \'.gitkeep\',\n\'package-lock.json\', \'yarn.lock\'\n]);\nreturn excludedFiles.has(fileName) || fileName.startsWith(\'.\');\n}\n}
=== END FILE: 'file-processor.ts' ===
Size: 3988 bytes, Type: .ts

=== FILE: 'gpt-dir.ts' ===
#!/usr/bin/env node\nimport { Command } from \'commander\';\nimport chalk from \'chalk\';\nimport * as path from \'path\';\nimport * as fs from \'fs/promises\';\nimport { ConversionOptions } from \'./types\';\nimport { DirectoryConverter } from \'./converter\';\nconst program = new Command();\nprogram\n.name(\'gpt-dir\')\n.description(\'Convert directories into structured text files optimized for AI processing\')\n.version(\'1.0.0\');\nprogram\n.option(\'-i, --input <dirs...>\', \'input directories to convert\', [])\n.option(\'-o, --output <dir>\', \'output directory for the converted file\', \'./output\')\n.option(\'--minify [value]\', \'minify content by removing extra whitespace\', \'true\')\n.option(\'-m, --minify-flag [value]\', \'alternative minify flag\', \'true\')\n.option(\'--escape [value]\', \'escape special characters\', \'true\')\n.option(\'-e, --escape-flag [value]\', \'alternative escape flag\', \'true\')\n.option(\'--tree [value]\', \'include directory tree in output\', \'true\')\n.option(\'-t, --tree-flag [value]\', \'alternative tree flag\', \'true\')\n.option(\'--clean\', \'clean output directory before conversion\', false)\n.action(async (options) => {\ntry {\n// Validate input directories\nif (!options.input || options.input.length === 0) {\nconsole.error(chalk.red(\'‚ùå Error: At least one input directory must be specified\'));\nconsole.log(chalk.yellow(\'Use: gpt-dir -i <directory> [options]\'));\nprocess.exit(1);\n}\n// Validate input directories exist\nconst inputDirs: string[] = [];\nfor (const dir of options.input) {\nconst absolutePath = path.resolve(dir);\ntry {\nconst stats = await fs.stat(absolutePath);\nif (!stats.isDirectory()) {\nconsole.error(chalk.red(`‚ùå Error: ${dir} is not a directory`));\nprocess.exit(1);\n}\ninputDirs.push(absolutePath);\n} catch (error) {\nconsole.error(chalk.red(`‚ùå Error: Directory ${dir} does not exist`));\nprocess.exit(1);\n}\n}\n// Parse boolean options with multiple flag support\nconst parseBooleanOption = (value: string | boolean | undefined, defaultValue: boolean = true): boolean => {\nif (value === undefined) return defaultValue;\nif (typeof value === \'boolean\') return value;\nif (typeof value === \'string\') {\nconst lowerValue = value.toLowerCase();\nreturn lowerValue === \'true\' || lowerValue === \'1\' || lowerValue === \'yes\';\n}\nreturn defaultValue;\n};\nconst conversionOptions: ConversionOptions = {\ninputDirs,\noutputDir: path.resolve(options.output),\nminify: parseBooleanOption(options.minify || options.minifyFlag),\nescape: parseBooleanOption(options.escape || options.escapeFlag),\ntree: parseBooleanOption(options.tree || options.treeFlag),\nclean: options.clean || false\n};\nconsole.log(chalk.blue(\'üîß Configuration:\'));\nconsole.log(chalk.gray(`   Input directories: ${conversionOptions.inputDirs.join(\', \')}`));\nconsole.log(chalk.gray(`   Output directory: ${conversionOptions.outputDir}`));\nconsole.log(chalk.gray(`   Minify: ${conversionOptions.minify}`));\nconsole.log(chalk.gray(`   Escape: ${conversionOptions.escape}`));\nconsole.log(chalk.gray(`   Tree: ${conversionOptions.tree}`));\nconsole.log(chalk.gray(`   Clean: ${conversionOptions.clean}`));\nconsole.log();\n// Clean output directory if requested\nif (conversionOptions.clean) {\nconsole.log(chalk.yellow(\'üßπ Cleaning output directory...\'));\ntry {\nawait fs.rm(conversionOptions.outputDir, { recursive: true, force: true });\n} catch (error) {\n// Directory might not exist, that\'s OK\n}\n}\n// Perform conversion\nconst converter = new DirectoryConverter();\nawait converter.convert(conversionOptions);\n} catch (error) {\nconsole.error(chalk.red(\'‚ùå Conversion failed:\'));\nconsole.error(chalk.red(error instanceof Error ? error.message : String(error)));\nprocess.exit(1);\n}\n});\n// Handle graceful shutdown\nprocess.on(\'SIGINT\', () => {\nconsole.log(chalk.yellow(\'\\nüõë Conversion interrupted by user\'));\nprocess.exit(0);\n});\nprocess.on(\'uncaughtException\', (error) => {\nconsole.error(chalk.red(\'‚ùå Uncaught exception:\'), error);\nprocess.exit(1);\n});\nprocess.on(\'unhandledRejection\', (reason, promise) => {\nconsole.error(chalk.red(\'‚ùå Unhandled rejection at:\'), promise, chalk.red(\'reason:\'), reason);\nprocess.exit(1);\n});\n// Parse command line arguments\nprogram.parse();\n// Show help if no arguments provided\nif (process.argv.length <= 2) {\nprogram.help();\n}
=== END FILE: 'gpt-dir.ts' ===
Size: 4728 bytes, Type: .ts

=== FILE: 'tree-generator.ts' ===
import * as fs from \'fs/promises\';\nimport * as path from \'path\';\nimport { FileProcessor } from \'./file-processor\';\nexport class TreeGenerator {\nprivate fileProcessor = new FileProcessor();\nasync generateTree(rootPath: string, prefix: string = \'\', isLast: boolean = true): Promise<string> {\nconst stats = await fs.stat(rootPath);\nconst name = path.basename(rootPath);\nlet result = \'\';\nconst connector = isLast ? \'‚îî‚îÄ‚îÄ \' : \'‚îú‚îÄ‚îÄ \';\nconst icon = stats.isDirectory() ? \'üìÅ\' : this.getFileIcon(name);\nresult += `${prefix}${connector}${icon} ${name}/\\n`;\nif (stats.isDirectory()) {\nif (this.fileProcessor.shouldExcludeDirectory(name) && prefix !== \'\') {\nreturn result;\n}\ntry {\nconst items = await fs.readdir(rootPath);\nconst filteredItems = items.filter(item => {\nreturn !this.fileProcessor.shouldExcludeFile(item) && !this.fileProcessor.shouldExcludeDirectory(item);\n});\n// Sort items: directories first, then files\nconst sortedItems = await this.sortItems(rootPath, filteredItems);\nfor (let i = 0; i < sortedItems.length; i++) {\nconst itemPath = path.join(rootPath, sortedItems[i]);\nconst isLastItem = i === sortedItems.length - 1;\nconst newPrefix = prefix + (isLast ? \'    \' : \'‚îÇ   \');\nresult += await this.generateTree(itemPath, newPrefix, isLastItem);\n}\n} catch (error) {\n// Skip directories we can\'t read\n}\n}\nreturn result;\n}\nprivate async sortItems(rootPath: string, items: string[]): Promise<string[]> {\nconst itemsWithStats = await Promise.all(\nitems.map(async item => {\nconst itemPath = path.join(rootPath, item);\ntry {\nconst stats = await fs.stat(itemPath);\nreturn { name: item, isDirectory: stats.isDirectory() };\n} catch {\nreturn { name: item, isDirectory: false };\n}\n})\n);\nreturn itemsWithStats\n.sort((a, b) => {\nif (a.isDirectory && !b.isDirectory) return -1;\nif (!a.isDirectory && b.isDirectory) return 1;\nreturn a.name.localeCompare(b.name);\n})\n.map(item => item.name);\n}\nprivate getFileIcon(fileName: string): string {\nconst ext = path.extname(fileName).toLowerCase();\nconst iconMap: Record<string, string> = {\n\'.js\': \'üü®\',\n\'.ts\': \'üî∑\',\n\'.jsx\': \'‚öõÔ∏è\',\n\'.tsx\': \'‚öõÔ∏è\',\n\'.html\': \'üåê\',\n\'.css\': \'üé®\',\n\'.scss\': \'üé®\',\n\'.less\': \'üé®\',\n\'.json\': \'üìã\',\n\'.md\': \'üìñ\',\n\'.txt\': \'üìÑ\',\n\'.yml\': \'üîß\',\n\'.yaml\': \'üîß\',\n\'.xml\': \'üìã\',\n\'.csv\': \'üìä\',\n\'.py\': \'üêç\',\n\'.java\': \'‚òï\',\n\'.cpp\': \'‚öôÔ∏è\',\n\'.c\': \'‚öôÔ∏è\',\n\'.php\': \'üêò\',\n\'.rb\': \'üíé\',\n\'.go\': \'üêπ\',\n\'.rs\': \'ü¶Ä\',\n\'.sh\': \'üíª\',\n\'.bat\': \'üíª\',\n\'.sql\': \'üóÉÔ∏è\'\n};\n// Configuration files\nconst configFiles = [\n\'package.json\', \'tsconfig.json\', \'webpack.config.js\',\n\'vite.config.js\', \'tailwind.config.js\', \'.env\'\n];\nif (configFiles.some(config => fileName.includes(config))) {\nreturn \'üîß\';\n}\nreturn iconMap[ext] || \'üìÑ\';\n}\n}
=== END FILE: 'tree-generator.ts' ===
Size: 3219 bytes, Type: .ts

=== FILE: 'types.ts' ===
export interface ConversionOptions {\ninputDirs: string[];\noutputDir: string;\nminify: boolean;\nescape: boolean;\ntree: boolean;\nclean: boolean;\n}\nexport interface FileStats {\ntotalFiles: number;\nprocessedFiles: number;\nskippedFiles: number;\nfileTypes: Record<string, number>;\ntotalSize: number;\n}\nexport interface ProcessedFile {\npath: string;\nrelativePath: string;\ncontent: string;\nsize: number;\ntype: string;\n}\nexport interface ConversionResult {\nstats: FileStats;\nfiles: ProcessedFile[];\ntree: string;\nstartTime: Date;\nendTime: Date;\n}
=== END FILE: 'types.ts' ===
Size: 581 bytes, Type: .ts

=== END FILES ===

=== END CONVERSION ===
